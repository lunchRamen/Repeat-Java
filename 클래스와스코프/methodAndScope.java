/*
함수:특정 작업을 처리할 수 있도록 만들어진 코드 묶음
함수=메서드=프로시저등등.

구현
여러가지 명령문을 조합,특정 작업을 처리하도록 코드를 작성 후
해당 함수에 이름을 붙여줘서 호출해서 작동하게끔.
**자바에서는 클래스 내부에서만 함수 구현,호출 가능.
**바로바로 쓰고싶으면 terminal에서 jshell호출해서 파이썬
idle처럼 interpreter같이 바로바로 쓸 수는 있다.

쓰는이유
문제를 (기능별로) 작게 쪼개려고.
비슷한 경우 재사용하려고
코드 수정 편하게 하려고
코드를 쉽게 짜고 가독성 높이려고

함수형태
return type funcName(parameter list){->head
    code            ->body
    return type;
}

함수 이름은 소문자 시작(클래스는 대문자 시작)

매개변수 쓰는 이유
융통성과 재사용성을 높이려고.

함수에 인자를 전달할때-> 파라미터 타입에 맞춰 자동 형변환.
매개변수가 더 넓은 자료형일때(역은 안됨)
ex) 매개변수: float 전달값: int -> float로 자동 형변환.

클래스 내부에 만들어지는 멤버함수들은 같은 클래스
내에 있는 모든 멤버변수에 직접 접근 가능
->이래서 같은 클래스 내에 getter setter를 만듬.
같은 클래스 내에 구현된 함수들은 순서에 상관없이
상호간 사용 가능.(c++,python과 가장 큰 차이점)

JShell에서 함수 구현순서.
클래스 내부에 함수를 구현 할 수도 있고, 단독으로 구현도 가능.
내부에 만들어지는 함수들은 컴파일러에서 쓸때랑 똑같이.
독립적으로 만들어지는 함수들은 c++처럼 정의순서에 따라 사용 가능.

return문 용도
1.return value; 코드 실행 중단하고 함수를 호출한곳으로 value를 결과로 반환.
2.return; ->그냥 코드 실행 종료시키고 함수 호출한 곳으로 되돌아가고싶을때.(재귀함수 같은경우)

함수의 경우의 수
입력O출력O  var1=func(var2);
입력X출력O  var1=func();       ->출력은 함수를 직접 봐야 알수 있음. 꼭 변수에 안넣어도 됨.
입력O출력X  func(var1);
입력X출력X  func();

매개변수 전달 방법
int add(int a,int b){
    return a+b;
}
int x=5,int y=6;
int sum=add(x,y);
x와 y의 값이 a와 b로 값의 형태로 복사돼서 전달.(call by value)
**자바에선 무조건 값을 전달하는 형태.(기본형,참조형 모두)
기본형은 값자체가 복사되니까 상관없다.
참조형에서 값전달=객체의 주소값을 복사하는 형태.
->같은곳을 가르키는거.
ex)
Integer i=1; i의 참조값은 1200이라 가정.
changeVar(i);

void changeVar(Integer a){
    a=123;
}
->여기서 파라미터 a는 i와 같은 참조값 1200을 할당받는데,
a=123;에서 123에 해당되는 참조값(1000이라 가정)으로 a의 값이 바뀐다.
i의 참조값은 여전히 1200. a의 참조값은 1000.

문제가 되는 경우
파라미터에 참조값을 전달할때 객체의 멤버변수를 바꾸는 경우,
함수가 끝난 후에 객체도 똑같이 변해있다.
why?같은걸 가르킨 상태로(같은 객체를 가르키고있는 상태)
    객체의 멤버변수를 바꾼다? 전달한 객체, 파라미터 객체 둘다 멤버변수가 바뀜.
배열도 참조형이기때문에, 함수를 통해서 배열의
값을 바꾸면 반환 후 돌아온 인자 배열 값도 바뀌어져있다.
why?같은 배열을 가르키고 있으니까.

java에선 swap함수 구현이 안됨.
swap:두개의 매개변수를 받아서 두개의 값을 서로 바꾸는 것.
why?바꿀수가 없음.(정확히는 함수 내부에선 바뀌는데, 함수가 끝나고난 후
swap 매개변수 인자로 전달된 인자값 두개는 바뀌어있지않음.)
ex)
void swap(Point a,Point b){
    Point temp=a;
    a=b;
    b=temp;
}
Point p1=10;
Point p2=20;
swap(10,20);
하면 p1의 주소 1000 p2의 주소 1200이라 가정
->10이란 값과 20이란 값은 다른 메모리공간에 있음.
a의 주소 1000 b의 주소 1200
->Point temp=a;에서 a의 값이 들어가는게 아니라
a의 참조값에 있는 실제 값이 새로운 메모리 공간에 할당돼서
temp에 저장됨. a의 참조값과 temp의 참조값은 다름.
*a의 참조값의 실제값과 temp의 참조값의 실제값은 같음.

일반적인 방법으론 swap못함. setter나 직접 바꿔야함.

변수의 scope.
네 가지 영역.
클래스 메소드 for반복문  코드블록.

클래스 유효범위
멤버변수 또는 멤버함수를 사용 할 수 있는 영역.

메소드 범위
메소드 내에서만 사용할 수 있는 영역.
ex)메소드 내부에서 사용하기 위한 임시변수.

for문 범위
for문 내에서 생성된 임시변수, 조건자등.

코드블록 범위
조건문,반복문 혹은 임의의 코드 블록 내에서 변수 정의
-> 그 블록내부에서만 범위가 유효함.
ex)if문 내 임시변수 -> if문 안에서만 사용가능.
{}->그냥 블록을 만들어서 범위 제한 가능.

*메소드에서 정의된 매개변수나 지역변수와 동일한 이름의
변수는 같은 코드블록 내에서 또 만드는거 불가능.
->클래스 내 멤버변수, 멤버함수의 매개변수와 같은 이름으로
임시변수를 만들 수 없다.

scope의 우선순위.
scope가 겹치는 영역에서 같은 이름의 변수가
두개 이상 정의되었을때?-> 해당 변수와 가장 가까운
코드블록 순으로 진행. 가장 가깝다=안쪽영역(inner scope)
*메소드에 전달된 파라미터도 메소드와 동일한 scope를 가진다.

method overloading(not overriding)
동일한 클래스 내에서 메소드의 이름은 같게,"매개변수"를 다르게 구현.
ex)
int add(int a,int b) return a+b;
double add(double a,double b) return a+b;
*반환 자료형만 다른경우 오버로딩 아님.
*매개변수의 타입을 바꾸거나, 갯수를 바꾸는 방법으로 오버로딩 가능



 */
class Add{
    public int add(int a,int b)
    {
        return a+b;
    }
    public double add(double a,double b)
    {
        return a+b;
    }
    public String add(String a,String b)
    {
        return a+b;
    }

}
public class methodAndScope {
    public static void main(String[] args) {
        int x=2,y=3;
        double a=2.3,b=3.14;
        String n="Hello",m=" World";
        Add c=new Add();
        System.out.printf("%d\n",c.add(x,y));
        System.out.printf("%f\n",c.add(a,b));
        System.out.printf("%s\n",c.add(n,m));
    }
}
